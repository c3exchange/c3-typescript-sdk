import { badRequestClientError, tooManyRequestsError } from "./error_helpers"

export const ClientErrors = {
    //General
    GeneralUnknownError : badRequestClientError(10000, "Unknown Error"),
    GeneralTooManyRequests : tooManyRequestsError(10001, "Too many requests"),
    GeneralInstrumentNotFound : badRequestClientError(10002, "Couldn't find instrument with asset id: {0}"),
    GeneralInvalidSignature : badRequestClientError(10003, "Invalid signature"),
    GeneralSignerIsNotAvailable : badRequestClientError(10004, "Signer is not available"),
    // Delegation
    DelegationInvalidSignature : badRequestClientError( 11000, "Couldn't validate signature for the user {0}"),
    DelegationInvalidNameLength : badRequestClientError(11001, "Delegation name must be less than 32 characters"),
    DelegationCantWithdrawFromDelegatedAccount : badRequestClientError(11002, "Can't withdraw from delegated account"),
    DelegationNoViewAccess : badRequestClientError(11003, "Only the owner of the account can view their delegations"),
    DelegationCantCreateDelegation : badRequestClientError(11004, "Only the owner of the account can delegate"),
    DelegationInvalidDelegationTarget : badRequestClientError(11005, "Cannot delegate to yourself"),
    DelegationNoRevokePermission : badRequestClientError(11006, "Only the owner of the account can revoke delegation"),
    DelegationAlreadyInPlace : badRequestClientError(11007, "A delegation to that user is already in place"),
    DelegationNotFound : badRequestClientError(11008, "Invalid delegation id for the user or already revoked"),
    DelegationExpirationTimeTooLong : badRequestClientError(11009, "Expiration time cannot be more than the maximum allowed. The maximum time is {0} days"),
    // Operations ( Deposits / Withdraws / Redeems / Repays )
    OperationWithdrawInvalidFees : badRequestClientError(12000, "Not enough fees to withdraw {0}, expected fee: {1}, received fee: {2}"),
    OperationWithdrawInvalidBalance : badRequestClientError(12001, "Not enough balance and max borrow to withdraw {0}"),
    OperationWithdrawTRMUnsafeAddress : badRequestClientError(12002, "Unsafe Withdraw to destination Address: {0}, Chain: {1}."),
    OperationWithdrawWillResultMargin : badRequestClientError(12003, "Withdraw would result in negative available margin {0}"),
    OperationInvalidAccount : badRequestClientError(12004, "Operation Account ID {0} doesn't match with endpoint"),
    OperationUnknownOperationType : badRequestClientError(12005, "Unknown operation type {0}"),
    OperationWithdrawMissingFee : badRequestClientError(12006, "Invalid destination chain, fee not found"),
    OperationNotEnoughAvailableCash : badRequestClientError(12007, "Not enough available cash to perform the operation"),
    OperationRedeemAmountExceedsLoan : badRequestClientError(12008, "Not enough lend position to redeem"),
    OperationNotEnoughMargin : badRequestClientError(12009, "Not enough margin available to execute the borrow without netting"),
    OperationInvalidPoolMove : badRequestClientError(12010, "Pool move operation would result in negative available margin {0} or less than old margin {1}"),
    OperationDepositAmountMismatch : badRequestClientError(12011, "Amount in request {0} doesn't match the amount in the signed transaction {1}"),
    OperationDepositInvalidVAA : badRequestClientError(12012, "Invalid VAA, it doesn't match with the request. receivedInstrument.asaId: {0}, req.assetId: {1}, req.amount: {2}, amountBuffer: {3}"),
    OperationDepositInvalidRepayInVAA : badRequestClientError(12013, "Repay amount in request {0} doesn't match the repay amount encoded in VAA {1}"),
    OperationDepositTRMUnsafeAddress : badRequestClientError(12014, "Unsafe Deposit origin from Address: {0}, Chain: {1}."),
    // Prices
    PricesMissingOraclePrice : badRequestClientError(13000, "Couldn't find oracle price for asset id: {0}"),
    PricesMissingPriceSnapshot : badRequestClientError(13001, "Couldn't find price snapshot for market :{0}"),
    PricesSnapshotOutdated : badRequestClientError(13002, "Last price snapshot is not currently available for market :{0}, please retry later..."),
    PricesInvalidGranularityName : badRequestClientError(13003, "Invalid granularity {0}"),
    PricesPriceOracleIsNotAvailable: badRequestClientError(13004, "Price oracle is not available"),
    //Orders
    OrderNoLockedLiquidityAvailable : badRequestClientError(14000, "Not enough available liquidity in pool"),
    OrderNotEnoughFundsToOpenOrder : badRequestClientError(14001, "Not enough funds to open order"),
    OrderInvalidOrderAmount : badRequestClientError(14002, "Invalid order: sell amount can never be zero"),
    OrderInvalidOrderZeroAmount : badRequestClientError(14003, "Invalid order: both amounts are zero"),
    OrderBuyMarketOrderExceedsSlippage : badRequestClientError(14004, "Buy Market amount converted to Base is close to minimum allowed. Base Amount: {0}. Minimum: {1}"),
    OrderInvalidOrderPrice : badRequestClientError(14005, "Price {0} isn't a multiple for this pair. Price Quantum: {1}"),
    OrderInvalidOrderAmountMinQuantum : badRequestClientError(14006, "Base amount is not a multiple. Base Amount: {0}. Amount Quantum: {1}"),
    OrderInvalidOrderAmountBelowMin : badRequestClientError(14007, "Base amount is less than the minimum allowed. Base Amount: {0}. Minimum: {1}"),
    OrderInvalidOrderAmountAboveMax : badRequestClientError(14008, "Base amount is more than the maximum allowed. Base Amount: {0}. Maximum: {1}"),
    OrderInvalidExpirationTime : badRequestClientError(14009, "Order expiry {0} is not in the allowed range in UnixTime (seconds): [{0} - {1}]"),
    OrderMaxBorrowBelowShortfall : badRequestClientError(14010, "Max Borrow/Redeem amount ({0}) is lower than expected order shortfall : ({1})"),
    OrderMismatchingCreatorAddress : badRequestClientError(14011, "Creator address does not match the one in request"),
    OrderUnexpectedError: badRequestClientError(14012, "Unexpected error creating order"),
    OrderInvalidSignature : badRequestClientError(14013, "Order {0} has invalid signature for user {1}"),
    OrderInvalidAccountFormat : badRequestClientError(14014, "Expected Base64 of the public key {0} (derived from order account address)"),
    OrderCancelInvalidUserSignature : badRequestClientError(14015, "Couldn't verify the signature for user {0}"),
    OrderCancelMissingAccountForAddress : badRequestClientError(14016, "Cant find Account Info for user Address : {0}"),
    OrderCancelAllParameterMismatch : badRequestClientError(14017, "Wrong parameters allOrdersUntil and orders where both undefined."),
    OrderUnhealthyStateError : badRequestClientError(14018, "Opening this order would put the account in an unhealthy state"),
    OrderInvalidMaxBorrow : badRequestClientError(14019, "Specified order margin is not enough to cover cost"),
    OrderNotEnoughFundsToOpenMarginOrder : badRequestClientError(14020, "Not enough funds in the system to open margin order, please try again later"),
    OrderNotEnoughCash: badRequestClientError(14021, "Not enough cash or max borrow to open the order. Cash: {0}, Max Borrow: {1}, Sell Amount (With Fees): {2}"),
    //Liquidation Errors
    LiquidationAccountIsHealthy : badRequestClientError(15000, "Target Account ID {0} is healthy therefore it cannot be liquidated"),
    LiquidationAccountThresholdNotReached : badRequestClientError(15001, "Target Account ID {0} health ({1}) is lower than min liquidation threshold {2}"),
    LiquidationLiquidatorDoesntHaveMargin : badRequestClientError(15002, "Liquidator doesn't have enough available margin for this operation"),
    LiquidationInProgress : badRequestClientError(15003, "User {0} is currently going through a liquidation process, no operation can be accepted until it's finished."),
    LiquidationBasketInvalidInstrumentId : badRequestClientError(15004, "Instrument not found for asset id {0} in {1} basket"),
    LiquidationBasketMissingPrice : badRequestClientError(15005, "Price not found for asset id {0} in {1} basket"),
    LiquidationBasketInvalidAmount : badRequestClientError(15006, "Found negative or zero cash in basket for asset id {0}"),
    LiquidationInvalidLiquidationTargetDefinition : badRequestClientError(15007, "Liquidatee was not defined correctly"),
    LiquidationCantSelfLiquidate : badRequestClientError(15008, "Cannot liquidate yourself"),
    LiquidationInvalidBasketBalance : badRequestClientError(15009, "Liquidation requested collateral value ({0} USD) is greater than assumed debt value ({1} USD)"),
    LiquidationZeroPoolAmountForAsset : badRequestClientError(15010, "Found zero principal in pool basket for asset id {0}"),
    LiquidationBasketAmountExceedsAvailableBalance: badRequestClientError(15011, "Amount specified in basket for {0} and assetId {1} is greater than available"),
    LiquidationLiquidatedUserBecomeHealthy : badRequestClientError(15012, "User {0} is healthy after orders are closed therefore it cannot be liquidated"),
    LiquidationInvalidLiquidatedUser : badRequestClientError(15013, "Target user {0} does not exist"),
    LiquidationBasketOrdering : badRequestClientError(15014, "Instruments in basket should be ordered strictly ascending by SlotId"),
}